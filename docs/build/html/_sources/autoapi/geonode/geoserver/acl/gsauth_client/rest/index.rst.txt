geonode.geoserver.acl.gsauth_client.rest
========================================

.. py:module:: geonode.geoserver.acl.gsauth_client.rest

.. autoapi-nested-parse::

   GeoServer ACL

   GeoServer Access Control List API  # noqa: E501

   The version of the OpenAPI document: 1.0.0
   Generated by: https://openapi-generator.tech



Attributes
----------

.. autoapisummary::

   geonode.geoserver.acl.gsauth_client.rest.logger


Classes
-------

.. autoapisummary::

   geonode.geoserver.acl.gsauth_client.rest.RESTResponse
   geonode.geoserver.acl.gsauth_client.rest.RESTClientObject


Module Contents
---------------

.. py:data:: logger

.. py:class:: RESTResponse(resp)

   Bases: :py:obj:`io.IOBase`


   The abstract base class for all I/O classes.

   This class provides dummy implementations for many methods that
   derived classes can override selectively; the default implementations
   represent a file that cannot be read, written or seeked.

   Even though IOBase does not declare read, readinto, or write because
   their signatures will vary, implementations and clients should
   consider those methods part of the interface. Also, implementations
   may raise UnsupportedOperation when operations they do not support are
   called.

   The basic type used for binary data read from or written to a file is
   bytes. Other bytes-like objects are accepted as method arguments too.
   In some cases (such as readinto), a writable object is required. Text
   I/O classes work with str data.

   Note that calling any method (except additional calls to close(),
   which are ignored) on a closed stream should raise a ValueError.

   IOBase (and its subclasses) support the iterator protocol, meaning
   that an IOBase object can be iterated over yielding the lines in a
   stream.

   IOBase also supports the :keyword:`with` statement. In this example,
   fp is closed after the suite of the with statement is complete:

   with open('spam.txt', 'r') as fp:
       fp.write('Spam and eggs!')


   .. py:attribute:: urllib3_response


   .. py:attribute:: status


   .. py:attribute:: reason


   .. py:attribute:: data


   .. py:method:: getheaders()

      Returns a dictionary of the response headers.



   .. py:method:: getheader(name, default=None)

      Returns a given response header.



.. py:class:: RESTClientObject(configuration, pools_size=4, maxsize=None)

   Bases: :py:obj:`object`


   .. py:attribute:: addition_pool_args


   .. py:method:: request(method, url, query_params=None, headers=None, body=None, post_params=None, _preload_content=True, _request_timeout=None)

      Perform requests.

      :param method: http request method
      :param url: http request url
      :param query_params: query parameters in the url
      :param headers: http request headers
      :param body: request json body, for `application/json`
      :param post_params: request post parameters,
                          `application/x-www-form-urlencoded`
                          and `multipart/form-data`
      :param _preload_content: if False, the urllib3.HTTPResponse object will
                               be returned without reading/decoding response
                               data. Default is True.
      :param _request_timeout: timeout setting for this request. If one
                               number provided, it will be total request
                               timeout. It can also be a pair (tuple) of
                               (connection, read) timeouts.



   .. py:method:: GET(url, headers=None, query_params=None, _preload_content=True, _request_timeout=None)


   .. py:method:: HEAD(url, headers=None, query_params=None, _preload_content=True, _request_timeout=None)


   .. py:method:: OPTIONS(url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None)


   .. py:method:: DELETE(url, headers=None, query_params=None, body=None, _preload_content=True, _request_timeout=None)


   .. py:method:: POST(url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None)


   .. py:method:: PUT(url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None)


   .. py:method:: PATCH(url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None)


